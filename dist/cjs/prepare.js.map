{"version":3,"file":"prepare.js","names":["_tsExifParser","require","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty2","default","getOwnPropertyDescriptors","defineProperties","defineProperty","isFileTypeValid","file","allowedTypes","some","allowedType","type","isFileSizeValid","maxSize","size","isImageMinSizeValid","image","options","minWidth","minHeight","width","height","isImageMaxSizeValid","maxWidth","maxHeight","handleOrientationAllowed","orientationAllowed","_ref","_ref2","_ref3","_ref4","resizeAndConvert","Promise","resolve","reject","exif","document","createElement","onload","canvas","context","getContext","autoCrop","_options$maxWidth","_options$maxHeight","_options$minWidth","_options$minHeight","lessCrop","maxWRatio","maxHRatio","ratios","ratio","Math","min","_toConsumableArray2","max","newWidth","newHeight","minWRatio","minHRatio","sourceWidth","sourceHeight","x","y","drawImage","metadata","name","value","String","quality","lat","lon","toBlob","blob","nameSplit","split","pop","nameParts","concat","replace","newFile","File","join","outputType","reader","FileReader","event","result","target","urlCreator","window","URL","webkitURL","Data","ExifParserFactory","create","parse","tags","GPSLatitude","GPSLongitude","src","createObjectURL","readAsArrayBuffer","imagePrepare","exports","_ref5","_asyncToGenerator2","_regenerator","mark","_callee","imageOptions","wrap","_context","prev","next","then","res","catch","stop","_x","_x2"],"sources":["../../src/prepare.ts"],"sourcesContent":["import { ExifParserFactory } from \"ts-exif-parser\";\n\ninterface metadata {\n  name: string;\n  value: string | Blob;\n  fileName?: string;\n}\n\nexport interface ImagePrepareOptions {\n  /**\n   * File name\n   * @default 'file'\n   */\n  name?: string;\n\n  /**\n   * Max File Size\n   * @default 20971520\n   */\n  maxSize?: number;\n\n  /**\n   * Image AllowedTypes Format types MIME\n   * @default ['image/jpeg', 'image/png']\n   */\n  allowedTypes?: Array<string>;\n\n  /**\n   * Image AllowedTypes Format types MIME\n   * @default 'image/jpeg'\n   */\n  outputType?: string;\n\n  /**\n   * Compression quality of the jpeg conversion\n   * @default 0.75\n   */\n  quality?: number;\n\n  /** Max width of the image. If to big, image is resized */\n  maxWidth?: number;\n\n  /** Max height of the image. If to big, image is resized */\n  maxHeight?: number;\n\n  /** Min width of the image. If to small, throw an error */\n  minWidth?: number;\n\n  /** Min height of the image. If to small, throw an error */\n  minHeight?: number;\n\n  /**\n   * If true, the max/min Width & Height are interchangeables for validation & resize.\n   * @default true\n   */\n  orientationAllowed?: boolean;\n\n  /**\n   * If true, the exceeding part will be crop.\n   * @default false\n   */\n  autoCrop?: boolean;\n\n  /**\n   * Resize strategy when the picture is too big (keep the ratio)\n   * False => Biggest pictures possible, max resolution but can crop a huge part of the picture\n   * True => Keep the most of the picture, min crop but can drop the quality of the picture\n   * @default true\n   */\n  lessCrop?: boolean;\n}\n\n/**\n * Check if allowed type\n * @param image\n * @param options\n * @returns boolean\n */\nconst isFileTypeValid = (file: File, allowedTypes: Array<string>) => {\n  return (\n    !allowedTypes ||\n    allowedTypes.some((allowedType) => allowedType === file.type)\n  );\n};\n\n/**\n * Check if file is too heavy\n * @param image\n * @param options\n * @returns boolean\n */\nconst isFileSizeValid = (file: File, maxSize: number) => {\n  return !maxSize || file.size < maxSize;\n};\n\n/**\n * Check if image is big enough\n * @param image\n * @param options\n * @returns boolean\n */\nconst isImageMinSizeValid = (\n  image: HTMLImageElement,\n  options: ImagePrepareOptions\n) => {\n  return (\n    !(options.minWidth && options.minHeight) ||\n    (image.width >= options.minWidth && image.height >= options.minHeight)\n  );\n};\n\n/**\n * Check if image is small enough\n * @param image\n * @param options\n * @returns boolean\n */\nconst isImageMaxSizeValid = (\n  image: HTMLImageElement,\n  options: ImagePrepareOptions\n) => {\n  return (\n    !(options.maxWidth && options.maxHeight) ||\n    (image.width <= options.maxWidth && image.height <= options.maxHeight)\n  );\n};\n\n/**\n * If orientationAllowed, handle big side/small side instead of width/height\n * @param image\n * @param options\n */\nconst handleOrientationAllowed = (\n  image: HTMLImageElement,\n  options: ImagePrepareOptions\n) => {\n  if (!options.orientationAllowed) return;\n\n  // handle max size. If image is wider than higher we make sur that maxWidth is bigger than maxHeight\n  // if not we swap max size\n  if (options.maxHeight && options.maxWidth) {\n    if (image.width > image.height) {\n      if (options.maxHeight > options.maxWidth) {\n        [options.maxHeight, options.maxWidth] = [\n          options.maxWidth,\n          options.maxHeight,\n        ];\n      }\n    } else if (options.maxHeight < options.maxWidth) {\n      [options.maxHeight, options.maxWidth] = [\n        options.maxWidth,\n        options.maxHeight,\n      ];\n    }\n  }\n\n  // handle min size. If image is wider than higher we make sur that minWidth is bigger than minHeight\n  // if not we swap min size\n  if (options.minHeight && options.minWidth) {\n    if (image.width > image.height) {\n      if (options.minHeight > options.minWidth) {\n        [options.minHeight, options.minWidth] = [\n          options.minWidth,\n          options.minHeight,\n        ];\n      }\n    } else if (options.minHeight < options.minWidth) {\n      [options.minHeight, options.minWidth] = [\n        options.minWidth,\n        options.minHeight,\n      ];\n    }\n  }\n};\n\n/**\n * Optimize a file\n * Handle validation error\n * @param file\n * @param options\n * @returns a promise resolving to a new file and is metadata (otherwise a validation error)\n */\nconst resizeAndConvert = (\n  file: File,\n  options: ImagePrepareOptions\n): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    let exif: any;\n\n    const image = document.createElement(\"img\");\n    image.onload = () => {\n      const canvas = document.createElement(\"canvas\");\n      const context = canvas.getContext(\"2d\")!;\n      let { width, height } = image;\n\n      handleOrientationAllowed(image, options);\n\n      if (!isImageMinSizeValid(image, options)) {\n        reject(\"minsize\");\n      }\n\n      if (!options.autoCrop && !isImageMaxSizeValid(image, options)) {\n        reject(\"maxsize\");\n      }\n\n      // if no max/min size, set max/min size to width/height\n      const {\n        maxWidth = width,\n        maxHeight = height,\n        minWidth = width,\n        minHeight = height,\n        lessCrop,\n      } = options;\n\n      // Define ratio to have the biggest image allowed\n      const maxWRatio = maxWidth / width;\n      const maxHRatio = maxHeight / height;\n      const ratios = [maxWRatio, maxHRatio].filter((ratio) => ratio < 1);\n      let ratio = 1;\n      if (ratios.length > 0) {\n        ratio = lessCrop ? Math.min(...ratios) : Math.max(...ratios);\n      }\n      let newWidth = width * ratio;\n      let newHeight = height * ratio;\n\n      // Make sure the ratio respect min size if we need to resize down the image\n      if (newWidth < minWidth || newHeight < minHeight) {\n        const minWRatio = minWidth / width;\n        const minHRatio = minHeight / height;\n        const ratios = [minWRatio, minHRatio].filter((ratio) => ratio < 1);\n        ratio = ratios.length > 0 ? Math.max(...ratios) : 1;\n        newWidth = width * ratio;\n        newHeight = height * ratio;\n      }\n\n      let sourceWidth = newWidth > maxWidth ? maxWidth / ratio : width;\n      let sourceHeight = newHeight > maxHeight ? maxHeight / ratio : height;\n      let x = 0;\n      let y = 0;\n\n      // if needed, offset the exceeding part on the x axis\n      if (newWidth > maxWidth) {\n        x = (width - sourceWidth) / 2;\n        newWidth = maxWidth;\n      }\n\n      // if needed, offset the exceeding part on the y axis\n      if (newHeight > maxHeight) {\n        y = (height - sourceHeight) / 2;\n        newHeight = maxHeight;\n      }\n\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      context.drawImage(\n        image,\n        x,\n        y,\n        sourceWidth,\n        sourceHeight,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n\n      const metadata: Array<metadata> = [\n        {\n          name: \"metadata[quality]\",\n          value: String(options.quality),\n        },\n      ];\n\n      if (exif && exif.lat && exif.lon) {\n        metadata.push(\n          {\n            name: \"metadata[lat]\",\n            value: exif.lat,\n          },\n          {\n            name: \"metadata[lon]\",\n            value: exif.lon,\n          }\n        );\n      }\n\n      canvas.toBlob(\n        (blob: Blob | null): void => {\n          if (!blob) {\n            reject(\"default\");\n          } else {\n            // Rename file with correct extension\n            const nameSplit = file.name.split(\".\");\n            nameSplit.pop();\n\n            const nameParts = [...nameSplit, blob.type.replace(\"image/\", \"\")];\n            const newFile = new File([blob], nameParts.join(\".\"), {\n              type: blob.type,\n            });\n\n            resolve({\n              file: newFile,\n              metadata,\n            });\n          }\n        },\n        options.outputType,\n        options.quality\n      );\n    };\n\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      const result = event.target!.result;\n\n      const urlCreator = window.URL || window.webkitURL;\n\n      if (result && typeof result !== \"string\") {\n        const Data = ExifParserFactory.create(result).parse();\n        if (Data && Data.tags!.GPSLatitude && Data.tags!.GPSLongitude) {\n          const lat = String(Data.tags!.GPSLatitude);\n          const lon = String(Data.tags!.GPSLongitude);\n          exif = { lat, lon };\n        }\n      }\n      image.src = urlCreator.createObjectURL(file);\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};\n\n/**\n * Optimize a file\n * Handle validation error\n * @param blob\n * @param options\n * @returns a promise resolving to a new file and is metadata (otherwise a validation error)\n */\nexport const imagePrepare = (\n  blob: Blob,\n  options: ImagePrepareOptions\n): Promise<any> => {\n  return new Promise(async (resolve, reject) => {\n    const imageOptions = {\n      name: \"file\",\n      maxSize: 20971520,\n      allowedTypes: [\"image/jpeg\", \"image/png\"],\n      outputType: \"image/jpeg\",\n      quality: 0.75,\n      orientationAllowed: true,\n      autoCrop: false,\n      lessCrop: true,\n      ...options,\n    };\n\n    const file = new File([blob], imageOptions.name, { type: blob.type });\n\n    if (!isFileTypeValid(file, imageOptions.allowedTypes)) {\n      reject(\"invalid_filetype\");\n    }\n\n    if (!isFileSizeValid(file, imageOptions.maxSize)) {\n      reject(\"invalid_filesize\");\n    }\n\n    resizeAndConvert(file, imageOptions)\n      .then((res) => {\n        resolve(res);\n      })\n      .catch((e) => {\n        reject(e);\n      });\n  });\n};\n"],"mappings":"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","ignoreList":[]}